[{"title":"利用 Xposed 快速实现一个简易微信机器人","date":"2018-05-09T05:26:00.000Z","path":"2018/05/09/利用-Xposed-快速实现一个简易微信机器人/","text":"本文同步至：https://www.jianshu.com/p/8d0d0b52bec6 目标当前微信网页版限制越来越多，考虑尝试在手机上实现类似机器人的功能。本文目的是利用 Xposed 快速实现简易机器人功能，包括获取好友发来的消息，以及回复消息。后续可以增加智能回复，比如接入图灵机器人，或者自己自定义实现一些功能。 快速实现项目框架的搭建WechatSpellbook - 站在”巨人”的肩膀上WechatSpellbook 是微信巫师作者在微信巫师的基础提取出来的通用微信 Xposed 插件框架。它提供了友好的的 API，提供自动分析微信内部结构特征的API(忽略微信版本差异)，对 hook 微信出现的常见问题都做了优化，总之就是使用它会更容易对微信 hook，感谢作者的贡献，项目的集成和详细介绍参见wiki，以下步骤的实现都是基于这个框架的。以下源码均基于微信 6.6.6 版本，由于使用了 WechatSpellbook 框架动态匹配的原理，大部分微信版本均可自动适配。 获得好友发来的消息实现机器人功能的首要步骤就是获得好友发来的消息，获得消息之后才能回复吧，才能叫“机器人”吧。使用了 WechatSpellbook，获取消息是很容易的，参见api，当新消息存入数据库后回调，具体代码：12345678910111213141516object WechatMessageHook : IMessageStorageHook &#123; override fun onMessageStorageInserted(msgId: Long, msgObject: Any) &#123; XposedBridge.log(\"onMessageStorageInserted msgId=$msgId,msgObject=$msgObject\") // 这些都是消息的属性，内容，发送人，类型等 val field_content = XposedHelpers.getObjectField(msgObject, \"field_content\") as String? val field_talker = XposedHelpers.getObjectField(msgObject, \"field_talker\") as String? val field_type = (XposedHelpers.getObjectField(msgObject, \"field_type\") as Int).toInt() val field_isSend = (XposedHelpers.getObjectField(msgObject, \"field_isSend\") as Int).toInt() XposedBridge.log(\"field_content=$field_content,field_talker=$field_talker,\" + \"field_type=$field_type,field_isSend=$field_isSend\") if (field_isSend == 1) &#123;// 代表自己发出的，不处理 return &#125; // 做其他事情 &#125;&#125; 其中字段名含义如下： field_content： 消息内容 field_talker： 发送者 field_type： 消息类型 field_isSend： 是谁发出的，我自己发出为1这步到此就完成了，下一步是机器人怎么将消息回复给好友。 机器人回复消息机器人回复消息需要找到发送消息出去这个 API，然后 hook 它，在我们的代码里调用就行了。 利用 Monitor 的 Method Profiling 功能分析首先在模拟器中打开微信聊天窗口，打开 Monitor，选中微信进程，点击Start Method Profiling，然后在聊天窗口随便发送一条消息，然后回来点击Stop Method Profiling，会生成分析文件。分析步骤如下： 先搜索 click，点击发送按钮，肯定是触发了点击事件的嘛，先找找看 image.png 发现调用了 ChatFooter$3.onClick() 方法，单从名字上来看，应该就是这里了，点进去，看这个函数调用了哪里 image.png 它调用了 chatting.o.FZ 方法，注意参数是 String，返回值是 Boolean，大胆猜测一下，这个字符串就是消息文本，返回值应该是发送是否成功。验证一下，直接 Hook 这个函数，运行发现猜测是真的，这里比较简单就不贴代码了。 分析到这里，已经知道了chatting.o.FZ 方法就是发送消息的，参数就是消息文本，但是有个很重要的地方忽略了，为什么没有接收者参数？，微信内部联系人 ID 一般是以 wx_idxxx 开头的，接收者 id 设置在哪，怎么设置 hook，现在就差这个问题了。到这里已经知道了发送消息的 API，hook 掉就可以搞事情了，但是缺少接收者这个重要参数的设置，分析下源码吧。 反编译查看源码分析反编译之后分析 chatting.o.FZ 方法源码：12345public final boolean FZ(String str) &#123; mS(false); ctQ(); return this.yOg.yRO.dt(str, 0); &#125; 然后分析yOg.yRO.dt方法，它是com.tencent.mm.ui.chatting.b类的方法，看下源码：1234567891011121314151617public final boolean dt(String str, int i) &#123; int i2 = 0; String Xf = bh.Xf(str); if (Xf == null || Xf.length() == 0) &#123; w.e(\"MicroMsg.ChattingUI.TextImp\", \"doSendMessage null\"); return false; &#125; x xVar = this.yXC; if (!ah.oB(Xf)) &#123; az azVar = new az(); azVar.setContent(Xf); azVar.eW(1); xVar.aB(azVar); &#125; bt btVar = new bt(); // 省略&#125; 可以看到在azVar.setContent(Xf);这里将发送的消息文本放在放在了az这个类中，setContent() 是 az 的父类com.tencent.mm.g.c.cg的方法，看下这个类的源码：1234567891011121314151617181920212223// 截取了几个方法public final void av(long j) &#123; this.field_createTime = j; this.eRw = true;&#125;public final long wQ() &#123; return this.field_createTime;&#125;public final void ed(String str) &#123; this.field_talker = str; this.feh = true;&#125;public final String wR() &#123; return this.field_talker;&#125;public final void setContent(String str) &#123; this.field_content = str; this.eRE = true;&#125; 只截取了几个方法，可以看到这个类不仅仅包含消息文本，还包含了接受者field_talker，发送时间field_createTime等，大胆猜想，这个类就是消息的包装类，包含消息所有的属性，这里关注的字段是接收者 field_talker，只要知道在哪里调用了ed方法 hook 掉就可以为所欲为了。但是，通过 AS 查找调用这个的地方有很多，根本无法判断具体发消息是哪里调用了，怎么办。借助 Xposed 分析com.tencent.mm.g.c.cg.ed()方法，也就是设置接收者 field_talker 的方法，只要 hook 这个方法，然后打印出调用堆栈看看到底是哪里回调了。12345678val clz = XposedHelpers.findClass(\"com.tencent.mm.g.c.cg\", WechatGlobal.wxLoader)XposedHelpers.findAndHookMethod(clz, \"ed\", String::class.java, object : XC_MethodHook() &#123; override fun beforeHookedMethod(param: MethodHookParam?) &#123; log(\"set field_talker start\") LogUtil.logStackTraces() // 打印调用堆栈 log(\"set field_talker end\") &#125;&#125;) 打印结果： image.png 可以看到函数调用链，关键点在com.tencent.mm.modelmulti.i.&lt;init&gt;，看下这个方法的源码：12345678910111213141516public i(String str, String str2, int i, int i2, Object obj) &#123; w.d(\"MicroMsg.NetSceneSendMsg\", \"dktext :%s\", new Object[]&#123;bh.cjG()&#125;); if (!bh.oB(str)) &#123; cg azVar = new az(); azVar.eV(1); azVar.ed(str); azVar.av(bd.in(str)); azVar.eW(1); azVar.setContent(str2); azVar.setType(i); String a = a(((o) g.l(o.class)).s(azVar), obj, i2); if (!bh.oB(a)) &#123; azVar.ej(a); w.d(\"MicroMsg.NetSceneSendMsg\", \"NetSceneSendMsg:MsgSource:%s\", new Object[]&#123;azVar.fnF&#125;); // 省略很多代码&#125; 可以看到这个类的构造方法实例化了cg azVar = new az();，并调用了ed()方法。分析下这个构造函数，很有意思的是：参数 str 就是微信 id，str2是文本内容，后几个不知道，大胆猜测下这个类就是去发送消息的，从源码很难分析，hook 掉看看。hook com.tencent.mm.modelmulti.i的构造方法打印参数，看下是否和发送消息有关。这里就不贴代码和截图了，结论是有关。那可以 hook 这个类的构造方法发送消息啊。 找到的 hook 关键点 com.tencent.mm.ui.chatting.o.FZ(String) 方法，参数是消息文本，调用该方法可以发消息，但是无法设置接收者 com.tencent.mm.modelmulti.i()构造方法，第0个参数是接收者 id，第1个参数是消息文本 机器人回复消息思路：调用第一个 API 发送消息文本，hook 第二个 API 修改接收者 id，然后就可以愉快的发消息了 关键点存在的问题上述 hook 思路存在的问题：当 hook 第二个API 时，不知道该条消息的接收者是谁，不太好设置。 问题解决方法既然我能 hook 这两个 API，那么我可不可以直接在调用第一个 API 的时候，将接收者 id 放在文本消息前面，然后在 hook 第二个 API 时将文本消息中的接收者 id 解析出来赋值给第0个参数。新消息文本 = 接收者ID + 分隔符号 + 真实消息文本分割符号可以采用特殊字符，用户不会输入的字符，比如 \\t 等 代码实现源码在这里，关键地方都有注释，有兴趣可以 star 效果图 image.png","tags":[{"name":"Xposed","slug":"Xposed","permalink":"https://blankeer.github.io/tags/Xposed/"},{"name":"微信","slug":"微信","permalink":"https://blankeer.github.io/tags/微信/"}]},{"title":"Xposed 模块免重启开发(借助VirtualXposed)","date":"2018-05-09T04:31:05.000Z","path":"2018/05/09/Xposed-模块免重启开发-借助VirtualXposed/","text":"本文同步至：https://www.jianshu.com/p/938e8c4c00df Xposed 模块开发痛点Xposed 模块修改之后是需要重启手机生效的，导致开发非常麻烦，改个代码运行还要重启，等待时间太长。 现有的方案搜索了一下，有现成的方案，原理大多是修改 Xposed FrameWork 源码实现，还有一种思路是动态加载。但都有点麻烦，还存在一些问题，偶尔失效只能重启。参考：https://github.com/shuihuadx/XposedHookhttps://www.jianshu.com/p/d5596196bd12https://bbs.pediy.com/thread-223713.htmhttp://androidwing.net/index.php/274 VirtualXposed 方案VirtualXposed 主要功能是在非ROOT环境下运行Xposed模块。使用之后觉得它比较适合模块开发，原因几下几点： 支持免重启手机激活模块 对开发者友好，详见 wiki 项目开源，作者很活跃，遇到什么问题很快可以得到答复 但是还是有一些缺点的： 不支持 x86，也就是不支持模拟器，只能使用真机 暂不支持资源HOOK 部分插件的兼容性有问题 不能 hook 系统 API 使用必须将需要 hook 的 APP 和模块 APP 安装到VirtualXposed 如果以上缺点提到的有涉及的就不能使用该方案 Gradle Task 实现自动重启 VirtualXposed，自动更新模块以下配置环境是 Android Studiowiki 里提供重启 VirtualXposed 、自动更新 APP，打开某 APP 的广播方式。利用这些可以编写Gradle Task 实现运行项目自动更新模块 APP，自动重启VirtualXposed，自动打开需要 hook 的 APP。需要先将需要 hook 的 APP 和模块先安装到 VirtualXposed，再进行以下设置： 将 Debug Configurations 里将 Gradle aware Make - 修改为 :app:installDebug image.png 修改 app/build.gradle 文件，在最下面增加如下代码123456789101112131415161718192021afterEvaluate &#123; installDebug.doLast &#123; updateVirtualXposedAPP.execute() rebootVirtualXposedAPP.execute() launchVirtualXposedAPP.execute() &#125;&#125;// 更新 VXP 中的 apptask updateVirtualXposedAPP(type: Exec) &#123; def pkg = android.defaultConfig.applicationId commandLine android.adbExecutable, 'shell', 'am', 'broadcast', '-a', 'io.va.exposed.CMD', '-e', 'cmd', 'update', '-e', 'pkg', pkg&#125;// 重启 VXPtask rebootVirtualXposedAPP(type: Exec) &#123; commandLine android.adbExecutable, 'shell', 'am', 'broadcast', '-a', 'io.va.exposed.CMD', '-e', 'cmd', 'reboot'&#125;// 重启 VXP 需要 hook 的 APP，需要知道它的包名task launchVirtualXposedAPP(type: Exec) &#123; def pkg = 'com.tencent.mm'// 需要 hook 的 app，这里是微信 commandLine android.adbExecutable, 'shell', 'am', 'broadcast', '-a', 'io.va.exposed.CMD', '-e', 'cmd', 'launch', '-e', 'pkg', pkg&#125; 具体代码参见：MDWechat原理就是利用 Gradle Task 使用 adb 发送广播。以上配置好就可以愉快的敲代码了。","tags":[{"name":"Xposed","slug":"Xposed","permalink":"https://blankeer.github.io/tags/Xposed/"},{"name":"VirtualXposed","slug":"VirtualXposed","permalink":"https://blankeer.github.io/tags/VirtualXposed/"}]},{"title":"[Huginn]我在 slack 发条消息,然后我的 vps 就重启了","date":"2018-03-21T16:43:51.000Z","path":"2018/03/22/Huginn-我在-slack-发条消息-然后我的-vps-就重启了/","text":"需求有时候重启 vps,需要登录在网页上操作,很麻烦,查了下有相关的 api 做这个事,最好是我在 slack 里发条消息(重启 xx 主机),然后自动重启. 重点实现的重点是 怎么让 Huginn 收到 slack 的消息,huginn 上的 slack agent 是发送消息到 slack, 而不能反过来,查了下 slack 文档,能实现的是 bot 和 app,决定采用 app 实现首先在 huginn 创建 WebhookAgent,options 如下:1234567&#123; \"secret\": \"123456\",//这里随便填 \"expected_receive_period_in_days\": 1, \"payload_path\": \".\", \"code\": \"200\", \"response\": \"&#123;&#123;challenge&#125;&#125;\"&#125; response 必须是,然后创建,可以看到 webhook api url ,一般是这种形式 http://1.2.3.4/users/1/web_requests/1/123456, 记下来,下一步会用.然后在 slack 创建 app, 然后创建 Event Subscriptions, image.png 然后填上上一步的 url, 添加 event, 填写 url 后会检查,如果失败,请检查上一步创建的 agent. image.png install APP, 然后授权下 image.png 以上步骤就 ok 了,然后你在公共 channel 里发条消息,检查下 agent events 有没有相关 event,类似这样: image.png 然后写一个 trigger agent 过滤出重启 的消息,然后传递给一个 Post agent去调用 vps 的 API,测试下就 ok 了.","tags":[{"name":"Huginn","slug":"Huginn","permalink":"https://blankeer.github.io/tags/Huginn/"},{"name":"VPS","slug":"VPS","permalink":"https://blankeer.github.io/tags/VPS/"},{"name":"Slack","slug":"Slack","permalink":"https://blankeer.github.io/tags/Slack/"}]},{"title":"Huginn 监控天气情况","date":"2018-03-21T16:42:14.000Z","path":"2018/03/22/Huginn-监控天气情况/","text":"需求监控天气是入门 agent 了,官方例子也有,我使用国内天气源,实现每两个小时通知我天气情况(温度,天气, pm2.5等) API天气情况当然得找 API 了,使用了这个 repo 里的 实现1234567891011121314151617181920212223&#123; \"expected_update_period_in_days\": \"2\", \"url\": \"http://tj.nineton.cn/Heart/index/all?city=替换成自己城市 code\", \"type\": \"json\", \"mode\": \"on_change\", \"extract\": &#123; \"city_name\": &#123; \"path\": \"weather[0].city_name\" &#125;, \"now_info\": &#123; \"path\": \"weather[0].now.text\" &#125;, \"temperature\": &#123; \"path\": \"weather[0].now.temperature\" &#125;, \"pm25\": &#123; \"path\": \"weather[0].now.air_quality.city.pm25\" &#125;, \"air_quality\": &#123; \"path\": \"weather[0].now.air_quality.city.quality\" &#125; &#125;&#125; 通知通知到 slack / email 就可以了.","tags":[{"name":"Huginn","slug":"Huginn","permalink":"https://blankeer.github.io/tags/Huginn/"},{"name":"天气","slug":"天气","permalink":"https://blankeer.github.io/tags/天气/"},{"name":"监控","slug":"监控","permalink":"https://blankeer.github.io/tags/监控/"}]},{"title":"Huginn 监控甩甩尾巴物品","date":"2018-03-21T16:40:18.000Z","path":"2018/03/22/Huginn-监控甩甩尾巴物品/","text":"需求当数字尾巴的甩甩尾巴有指定物品发布时,通知我! 实现 甩甩尾巴首页:http://trade.dgtle.com/dgtle_module.php?mod=trade&amp;ac=index&amp;typeid=&amp;PName=&amp;searchsort=0&amp;page=1,page 参数是页码,可以同时抓取2-3页,以免时间间隔过大发布的物品太多导致爬不到. 抓取每个物品的标题,url,地址,价格,时间,是否交易完成,提取这几个属性,使用 xpath 或者 css selector,在 w3c 上都有相关教程,推荐两个 chrome 插件,可以检查表达式的结果,CSS Selector Tester,XPath Helper 提取数据,通过 chrome 开发者工具,可以粗略提取下,然后自己修改下表达式,基本就可以了,通过上面的插件测试下,基本就差不多了. image.png 贴上我写好的配置文件,新建一个 Website Agent 导入就可以了. 123456789101112131415161718192021222324252627282930313233343536&#123; \"expected_update_period_in_days\": \"2\", \"url\": [ \"http://trade.dgtle.com/dgtle_module.php?mod=trade&amp;ac=index&amp;typeid=&amp;PName=&amp;searchsort=0&amp;page=1\", \"http://trade.dgtle.com/dgtle_module.php?mod=trade&amp;ac=index&amp;typeid=&amp;PName=&amp;searchsort=0&amp;page=2\", \"http://trade.dgtle.com/dgtle_module.php?mod=trade&amp;ac=index&amp;typeid=&amp;PName=&amp;searchsort=0&amp;page=3\" ], \"type\": \"html\", \"mode\": \"on_change\", \"extract\": &#123; \"title\": &#123; \"css\": \"div.tradetop &gt; p.tradetitle &gt; a\", \"value\": \"string(.)\" &#125;, \"info\": &#123; \"xpath\": \"//*[@id=\\\"wp\\\"]/div[3]/div/p[1]/.\", \"value\": \"normalize-space(.)\" &#125;, \"state\": &#123; \"css\": \"div.tradepic\", \"value\": \"not(contains(@class,'comp'))\" &#125;, \"date\": &#123; \"css\": \".tradedateline\", \"value\": \"string(.)\" &#125;, \"img\": &#123; \"css\": \".tradepic &gt; a &gt; img\", \"value\": \"@src\" &#125;, \"url\": &#123; \"css\": \".tradepic &gt; a\", \"value\": \"concat('http://trade.dgtle.com',@href)\" &#125; &#125;&#125; 过滤指定物品,需要创建一个Trigger Agent,过滤出小米相关物品,只要标题包含这个关键字就可以了,代码: 123456789101112&#123; \"expected_receive_period_in_days\": \"2\", \"keep_event\": \"true\", \"rules\": [ &#123; \"type\": \"regex\", \"value\": \"小米\", \"path\": \"title\" &#125; ], \"message\": \"甩甩尾巴有关 `小米` 的物品更新了\"&#125; 将 event 通知到 Slack, 也可以邮件或者其他.","tags":[{"name":"Huginn","slug":"Huginn","permalink":"https://blankeer.github.io/tags/Huginn/"},{"name":"监控","slug":"监控","permalink":"https://blankeer.github.io/tags/监控/"},{"name":"数字尾巴","slug":"数字尾巴","permalink":"https://blankeer.github.io/tags/数字尾巴/"},{"name":"甩甩尾巴","slug":"甩甩尾巴","permalink":"https://blankeer.github.io/tags/甩甩尾巴/"}]},{"title":"Huginn 安装笔记","date":"2018-03-21T16:37:32.000Z","path":"2018/03/22/Huginn-安装笔记/","text":"安装我用的 ubuntu + mysql, 按照教程安装,中途出现了很多问题,遇到问题搜索,好不容易才解决.机器配置是 1核+ 2G,日常CPU占用&lt;5%,内存50%,内存用的比较多, cpu 用的比较少,可能是我的 agent 不多吧. 使用通知通知尝试过 email slack pushbullet, 最终选择了 slack, 主要原因是: 便于管理,同类型的 event 放在同一个 channel 里,而且网络通畅 编写可以先在这里看下,有一些共享出来的scenarios,就算需求不同,也可以学习下 agent 编写的语法,很有帮助. 遇到的问题和解决 bundle install error “invalid byte sequence in US-ASCII (ArgumentError)” 可以先执行这个设置语言 123export LC_ALL=C.UTF-8export LANG=en_US.UTF-8export LANGUAGE=en_US.UTF-8 An error occurred while installing nokogiri (1.6.7.1), and Bundler cannot continue sudo apt-get install build-essential patch ruby-dev zlib1g-dev liblzma-dev 需要 swap 分区 搜索”阿里云开启 swap”,https://www.digitalocean.com/community/tutorials/how-to-add-swap-on-ubuntu-14-04 diagram加载不出来,挂掉 原因是访问不了 google 的 api,办法是下载离线的graphviz安装,.env修改USE_GRAPHVIZ_DOT=dot,重新执行sudo bundle exec rake production:export 参考:https://github.com/huginn/huginn/issues/2109 css 资源挂掉,界面很丑 先编译资源,sudo -u huginn -H bundle exec rake assets:precompile RAILS_ENV=production,直接重启,sudo bundle exec rake production:restart Mysql 设置 Innodb 出现 Unknown system variable ‘storage_engine 在/etc/mysql/my.cnf 中设置 [mysqld] default-storage-engine = InnoDB 时区设置 Schedule 的时间不是北京时间,.env修改 TIMEZONE=”Beijing” ​","tags":[{"name":"Huginn","slug":"Huginn","permalink":"https://blankeer.github.io/tags/Huginn/"}]},{"title":"Huginn Docker 安装笔记","date":"2018-03-21T16:29:14.000Z","path":"2018/03/22/Huginn-Docker-安装笔记/","text":"官方文档:https://github.com/huginn/huginn/blob/master/doc/docker/install.md官方文档没有详细说明 Docker 怎么和本机数据库连接的,以下是记录. 安装 Docker安装官方文档安装 安装 MySQL安装完成后的配置: 修改绑定 IP 为0.0.0.0, 修改/etc/mysql/mysql.conf.d/mysqld.cnf,bind-address = 0.0.0.0,重启 sudo service mysql restart 允许 docker 访问本机数据库,本机先执行ifconfig看下 docker0 的 ip,一般是172.17.0.1,那么 docker ip 为172.17.0.*,这里自己看情况修改.然后在数据库里给这个网段 IP 操作权限,12GRANT ALL PRIVILEGES ON *.* TO 'root'@'172.17.0.%' IDENTIFIED BY 'pass' WITH GRANT OPTION;flush privileges; 安装 Huginn 首次安装:1234567docker run --name huginn \\ -p 3000:3000 \\ -e MYSQL_PORT_3306_TCP_ADDR=172.17.0.1 \\ -e HUGINN_DATABASE_NAME=huginn \\ -e HUGINN_DATABASE_USERNAME=root \\ -e HUGINN_DATABASE_PASSWORD=pass \\ huginn/huginn 如果安装中数据库报错,看下原因修改.安装完成后,打开本机3000端口就可以进入首页.之后再打开,直接 docker start huginn就行了. 设置开机自启动:docker update --restart=always huginn 自定义 .env.example 文件在 docker run 下面加入 12docker run --name huginn \\ --env-file /本地路径/.env.example \\","tags":[{"name":"Huginn","slug":"Huginn","permalink":"https://blankeer.github.io/tags/Huginn/"},{"name":"Docker","slug":"Docker","permalink":"https://blankeer.github.io/tags/Docker/"}]},{"title":"Hello World","date":"2018-03-21T11:59:30.194Z","path":"2018/03/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"27--Remove-Element","date":"2018-01-23T14:03:00.000Z","path":"2018/01/23/27-Remove-Element/","text":"输入: 一个数组和一个数字输出: 数组不包含该数字的长度,并修改原数组.不能额外空间思路: 循环遍历, l 为目标数组最右边元素,初始=0,当遇到 nums[i] != val 时, l++ 并赋值.123456789101112class Solution &#123; public int removeElement(int[] nums, int val) &#123; int l=0; for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i]!=val)&#123; nums[l]=nums[i]; l++; &#125; &#125; return l; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"26--Remove-Duplicates-from-Sorted-Array","date":"2018-01-18T14:05:00.000Z","path":"2018/01/18/26-Remove-Duplicates-from-Sorted-Array/","text":"输入: 排好序的数组输出: 返回不重复的个数,并修改数组为不重复的数组,要求不能使用额外的空间思路: 循环判断前一个和当前是否相等,循环移动位置.12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length==0)&#123; return 0; &#125; int t=nums[0],res=nums.length; int l=0,r=-1,count=0; for(int i=1;i&lt;nums.length-count;i++)&#123; int item = nums[i]; if(item != t)&#123; t = item; r = i-1; int len=r-l; if(len&gt;=1)&#123; move(nums,l,r); count+=len; &#125; i-=len; l = i; &#125; &#125; r = nums.length-count-1; int len=r-l; if(len&gt;=1)&#123; move(nums,l,r); count+=len; &#125; return res - count; &#125; private void move(int[] nums,int l,int r)&#123; int len=r-l; for(int i=l+1;i&lt;nums.length-len;i++)&#123; nums[i]=nums[i+len]; &#125; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"24--Swap-Nodes-in-Pairs","date":"2018-01-16T15:25:00.000Z","path":"2018/01/16/24-Swap-Nodes-in-Pairs/","text":"https://leetcode.com/problems/swap-nodes-in-pairs/description/输入: 一个链表输出: 每两位颠倒要求: 不能使用额外空间,不能修改节点的值,只能修改引用 思路: 循环修改 next 即可,一次 AC12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode current=head,next,nextnext; ListNode result=new ListNode(-1); ListNode pre=result; result.next = head; while(current!=null&amp;&amp;(next=current.next)!=null)&#123; nextnext = next.next; pre.next=next; next.next=current; current.next=nextnext; pre=current; current = nextnext; &#125; return result.next; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"22--Generate-Parentheses","date":"2018-01-04T13:54:00.000Z","path":"2018/01/04/22-Generate-Parentheses/","text":"https://leetcode.com/problems/generate-parentheses/description/输入: 数字 n处理: n 对括号()的排列输出: 所有成对的结果思路: n 对括号,字符串长度就是2*n,每位是(或),由于 n 是参数动态的,所以不能采取循环,只能采取递归回溯实现,过程中需要剪枝.预处理左括号是1,右括号是-1,这样只要最终每位之和等于0就匹配了剪枝条件: 当前总和=0时,下一位只能是1,因为如果是-1后面再多都不会匹配 当前总和&lt;0时,直接剪枝 当前总和&gt;n时,直接剪枝,因为后面即使都是-1,总和也是大于0的 当前总和=n时,下一位只能是-1,因为如果是1,总和不会=0 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; char[] arr=&#123;'(',')'&#125;; int[] values=&#123;1,-1&#125;; List&lt;String&gt; res; public List&lt;String&gt; generateParenthesis(int n) &#123; res= new ArrayList&lt;String&gt;(); fun(0,n,0,new StringBuilder()); return res; &#125; private void fun(int i,int n,int sum,StringBuilder sb)&#123; if(i==n*2)&#123; if(sum==0)&#123; res.add(sb.toString()); &#125; return; &#125; if(sum == 0)&#123; sum = call(i,arr[0],values[0],sb,sum,n); &#125;else if(sum&gt;0)&#123; if(sum &gt; n)&#123; return; &#125;else if(sum &lt; n)&#123; sum = call(i,arr[0],values[0],sb,sum,n); &#125; sum = call(i,arr[1],values[1],sb,sum,n); &#125; &#125; private int call(int i,char c,int val,StringBuilder sb,int sum,int n)&#123; sb.append(c); sum+=val; fun(i+1,n,sum,sb); sb.deleteCharAt(sb.length()-1); sum-=val; return sum; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"21--Merge-Two-Sorted-Lists","date":"2017-12-21T13:31:00.000Z","path":"2017/12/21/21-Merge-Two-Sorted-Lists/","text":"https://leetcode.com/problems/merge-two-sorted-lists/description/输入: 两个排好序的链表输出: 两个链表连接起来,并且是排好序的 思路:循环遍历两个链表,判断当前节点的大小,需要注意长度不等12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null)&#123; return l2; &#125; if(l2==null)&#123; return l1; &#125; ListNode res = new ListNode(-1); ListNode i=l1,j=l2,item=res; do&#123; if(i!=null&amp;&amp;j!=null)&#123; if(i.val&lt;j.val)&#123; item.next=i; i=i.next; item=item.next; &#125;else&#123; item.next=j; j=j.next; item=item.next; &#125; &#125;else if(j==null)&#123; item.next=i; i=i.next; item=item.next; &#125;else if(i==null)&#123; item.next=j; j=j.next; item=item.next; &#125; &#125;while(i!=null||j!=null); return res.next; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"20--Valid-Parentheses","date":"2017-12-20T14:06:00.000Z","path":"2017/12/20/20-Valid-Parentheses/","text":"https://leetcode.com/problems/valid-parentheses/description/输入: 字符串包含 {}[]()处理:成对出现输出:是否成对思路:就是一个算数表达式成对问题,栈解决就好了1234567891011121314151617181920212223242526272829class Solution &#123; public boolean isValid(String s) &#123; List&lt;Character&gt; stack=new ArrayList(); for(int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); if(i&gt;0&amp;&amp;stack.size()&gt;0&amp;&amp;isMarch(stack.get(stack.size()-1),c))&#123; stack.remove(stack.size()-1); &#125;else&#123; if(c==')'||c=='&#125;'||c==']')&#123;//如果某步加入的是后者,那么肯定是不匹配的 return false; &#125; stack.add(c); &#125; &#125; return stack.size()==0; &#125; private boolean isMarch(char a,char b)&#123; if(a+b=='('+')')&#123; return true; &#125; if(a+b=='&#123;'+'&#125;')&#123; return true; &#125; if(a+b=='['+']')&#123; return true; &#125; return false; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"18--4Sum","date":"2017-12-19T13:46:00.000Z","path":"2017/12/19/18-4Sum/","text":"https://leetcode.com/problems/4sum/description/输入: 数组 和 target输出: 4个数字相加等于 target 的所有组合 和3sum 一样,多了个循环12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i=0;i&lt;nums.length-3;i++)&#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123; continue; &#125; for(int j=i+1;j&lt;nums.length-2;j++)&#123; if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1])&#123; continue; &#125; int k=j+1; int m=nums.length-1; while(k&lt;m)&#123; int sum = nums[i]+nums[j]+nums[k]+nums[m]; if(sum==target)&#123; res.add(Arrays.asList(nums[i],nums[j],nums[k],nums[m])); while(m-1&gt;=0&amp;&amp;nums[m]==nums[--m]); while(k+1&lt;nums.length&amp;&amp;nums[k]==nums[++k]); &#125;else if(sum&gt;target)&#123; m--; &#125;else&#123; k++; &#125; &#125; &#125; &#125; return res; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"15--3Sum","date":"2017-12-14T13:14:00.000Z","path":"2017/12/14/15-3Sum/","text":"https://leetcode.com/problems/3sum/description/输入: 数组输出: 3个数加起来等于0 的所有情况 思路:首先从小到大排序3个数分别是 i,j,ki 从 0~length-2 下标循环j 和 k 分别取 i+1 和 length-1然后 判断 i ,j, k 三个数和0比大小如果等于0 , 加入结果集如果&gt;0,k–如果&lt;0,j++需要注意的是重复的情况,比如 -4 -1 -1 0 1两个 -1 会导致 重复的 {-1 0 1} 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; if(nums.length==0)&#123; return res; &#125; Arrays.sort(nums); int lasti=0; for(int i=0;i&lt;nums.length-2;i++)&#123; if(nums[i]&gt;0)&#123; break; &#125; if(i&gt;0)&#123; if(nums[i]==lasti)&#123; continue; &#125; &#125; lasti=nums[i]; int j=i+1,k=nums.length-1; while(j&lt;k)&#123; int temp = add(nums,i,j,k); if(temp==0)&#123; int lastk=nums[k]; int lastj=nums[j]; res.add(Arrays.asList(nums[i],lastj,lastk)); while(k&gt;j&amp;&amp;nums[--k]==lastk); while(j&gt;k&amp;&amp;nums[++j]==lastj); &#125;else if(temp&gt;0)&#123; k--; &#125;else&#123; j++; &#125; &#125; &#125; return res; &#125; private int add(int[] nums,int i,int j,int k)&#123; return nums[i]+nums[j]+nums[k]; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"14--Longest-Common-Prefix","date":"2017-11-16T14:10:00.000Z","path":"2017/11/16/14-Longest-Common-Prefix/","text":"https://leetcode.com/problems/longest-common-prefix/discuss/输入: 字符串数组输出: 求公共最长前缀字符串 思路:先取出第0个 string, 依次比较后面的字符串,求公共前缀123456789101112131415161718192021222324class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if(strs.length ==0 )&#123; return \"\"; &#125; StringBuilder sb=new StringBuilder(); for(int i=0;i&lt;strs[0].length();i++)&#123; char c=strs[0].charAt(i); boolean isbreak = false; for(int j=1;j&lt;strs.length;j++)&#123; if(strs[j].length()&lt;=i||strs[j].charAt(i)!=c)&#123; isbreak=true; break; &#125; &#125; if(isbreak)&#123; break; &#125;else&#123; sb.append(c); &#125; &#125; return sb.toString(); &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"9--Palindrome-Number","date":"2017-11-15T13:55:00.000Z","path":"2017/11/15/9-Palindrome-Number/","text":"https://leetcode.com/problems/palindrome-number/discuss/判断一个数字是否是回文数思路:将数字逆序,判断是否相等.1234567891011121314class Solution &#123; public boolean isPalindrome(int x) &#123; if(x&lt;0)&#123; return false; &#125; int res=0; int source=x; while(source!=0)&#123; res=res*10+source%10; source=source/10; &#125; return x==res; &#125;&#125; 上面的 ac 了…看了下讨论,还有简单的做法.回文数只有两种情况: 位数是偶数 or 奇数位数是偶数情况: abccba, 存在一个位置,使得左边的数字 abc 和右边数字 cba 互为逆数位数是奇数情况: abcdcba,存在一个位置,使得左边的数字 abc 和右边数字 dcba 的逆数/10 相等1234567891011121314151617class Solution &#123; public boolean isPalindrome(int x) &#123; if(x==0)&#123; return true; &#125; if(x&lt;0 || x%10 == 0)&#123; return false; &#125; int res=0; int source=x; while(source&gt;res)&#123; res=res*10+source%10; source=source/10; &#125; return source==res || source == res/10; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"8--String-to-Integer-(atoi)","date":"2017-11-14T14:50:00.000Z","path":"2017/11/14/8-String-to-Integer-atoi/","text":"https://leetcode.com/problems/string-to-integer-atoi/discuss/实现 atoi 函数思路:循环按位解析,需要手动判断溢出等情况,写的有点乱,之后再精简下.1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int myAtoi(String str) &#123; str = str.trim(); if(str.length() == 0)&#123; return 0; &#125; int number=0; int fu=1; int startIndex=0; if(str.charAt(0)=='-')&#123; fu=-1; startIndex=1; &#125;else if(str.charAt(0)=='+')&#123; startIndex=1; &#125; for(int i=startIndex;i&lt;str.length();i++)&#123; char c=str.charAt(i); if(isNumber(c))&#123; int n=c-'0'; if(fu==1 &amp;&amp; ( number*10&gt;=(Integer.MAX_VALUE-n) || number&gt;Integer.MAX_VALUE/10 ))&#123; number=Integer.MAX_VALUE; return number; &#125;else if(fu==-1 &amp;&amp; (-10*number&lt;=(Integer.MIN_VALUE+n)|| number&gt;Integer.MIN_VALUE/-10 ))&#123; number=Integer.MIN_VALUE; return number; &#125; number=number*10+n; &#125;else&#123; break; &#125; &#125; return fu*number; &#125; private boolean isNumber(char c)&#123; return c&gt;='0'&amp;&amp;c&lt;='9'; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"7--Reverse-Integer","date":"2017-11-13T14:55:00.000Z","path":"2017/11/13/7-Reverse-Integer/","text":"https://leetcode.com/problems/reverse-integer/description/输入: 32位有符号 int输出: 逆序思路:循环取余就可以实现了,需要注意溢出的情况123456789101112131415class Solution &#123; public int reverse(int x) &#123; int t = x; int num = 0; while(t!=0)&#123; int temp = num*10 + t%10; if((temp-t%10)/10 != num)&#123; return 0; &#125; num = temp; t=t/10; &#125; return num; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"3--Longest-Substring-Without-Repeating-Characters","date":"2017-11-09T14:26:00.000Z","path":"2017/11/09/3-Longest-Substring-Without-Repeating-Characters/","text":"https://leetcode.com/problems/longest-substring-without-repeating-characters/description/输入: 字符串处理: 寻找不包含重复字符的最长子串输出: 最长子串的长度 思路:1.左指针始终指向当前子串的最左边,2.判断当前字符是否包含在当前子串中,如果在,左指针等于前面重复字符的下标+1,3.否则继续判断下一位字符4.记录每次子串长度的最大值其中第2步,可以简化为 当前左指针下标 和 重复字符下标+1 的最大值,因为: 如果当前字符不包含在当前子串中,而是在子串之前,求个最大值,也没什么不妥,代码看起来简洁很多.12345678910111213141516class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); int max=0; int left=0; for(int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); if(map.containsKey(c))&#123; left=Math.max(left,map.get(c)+1); &#125; max = Math.max(max,i-left+1); map.put(c,i); &#125; return max; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"2--Add-Two-Numbers","date":"2017-11-08T15:41:00.000Z","path":"2017/11/08/2-Add-Two-Numbers/","text":"https://leetcode.com/problems/add-two-numbers/description/输入: 两个链表,每个节点上有一个 val 值处理: 将对应节点的值加起来,结果保留个位,如果有进位,加到下一个节点上输出: 相加的结果链表 思路:加起来就行了,需要记录相加的值,并和10相除取余保存处理.123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode result = new ListNode(-1); ListNode temp1 = l1; ListNode temp2 = l2; ListNode temp3 = result; int num=0; while(temp1!=null || temp2!=null) &#123; if(temp1!=null) &#123; num+=temp1.val; temp1 = temp1.next; &#125; if(temp2!=null) &#123; num+=temp2.val; temp2 = temp2.next; &#125; ListNode item = new ListNode(num%10); temp3.next = item; temp3 = temp3.next; num=num/10; &#125; if(num!=0)&#123; ListNode item = new ListNode(num); temp3.next = item; &#125; return result.next; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"1--Two-Sum","date":"2017-11-08T15:12:00.000Z","path":"2017/11/08/1-Two-Sum/","text":"https://leetcode.com/problems/two-sum/description/输入: nums 数组 ,和 target 整型处理: 找到 nums 中两个数字相加等于 target输出: 输入这两个数字的下标 思路1循环两次,判断相加是否等于 target 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for(int i=0;i&lt;nums.length-1;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j] == target) &#123; return new int[]&#123;i,j&#125;; &#125; &#125; &#125; return new int[]&#123;-1,-1&#125;; &#125;&#125; 思路2看了讨论才想到的,惭愧,只需要 O(n),利用 HashMap 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(map.containsKey(target-nums[i]))&#123; return new int[]&#123;map.get(target-nums[i]),i&#125;; &#125; map.put(nums[i],i); &#125; return new int[]&#123;-1,-1&#125;; &#125;&#125; 类似数字对应的题目都可以考虑用下哈希表,可能会有很好的做法","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blankeer.github.io/tags/LeetCode/"}]},{"title":"Retrofit源码分析笔记","date":"2017-05-21T13:22:20.000Z","path":"2017/05/21/Retrofit源码分析笔记/","text":"Retrofit Version:2.2.0分析代码地址:https://github.com/Blankeer/source-analysis-retrofit 环境配置相关： 发现项目是基于Maven的，于是祭出许久不用的Idea 删掉了部分对源码无用的配置文件，比如website/,CHANGELOG.md等 samples分析 123456789101112131415161718192021222324252627public interface GitHub &#123; @GET(\"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors\") Call&lt;List&lt;Contributor&gt;&gt; contributors( @Path(\"owner\") String owner, @Path(\"repo\") String repo);&#125;// Create a very simple REST adapter which points the GitHub API.Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_URL) .addConverterFactory(GsonConverterFactory.create()) .build();// Create an instance of our GitHub API interface.GitHub github = retrofit.create(GitHub.class);// Create a call instance for looking up Retrofit contributors.Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(\"square\", \"retrofit\");call.enqueue(new Callback&lt;List&lt;Contributor&gt;&gt;() &#123; @Override public void onResponse(Call&lt;List&lt;Contributor&gt;&gt; call, Response&lt;List&lt;Contributor&gt;&gt; response) &#123; for (Contributor contributor : response.body()) &#123; System.out.println(contributor.login + \" (\" + contributor.contributions + \")\"); &#125; &#125; @Override public void onFailure(Call&lt;List&lt;Contributor&gt;&gt; call, Throwable t) &#123; &#125;&#125;); 这是最简单的用法,使用步骤: 定义一个 API 的 Interface.包含 API 的基本信息(url,method,path,call,返回类型等) 实例化Retrofit对象,配置 baseUrl 和 ConverterFactory 通过 retrofit.create 方法创建 API 实例对象 直接调用具体的 api 方法得到 Call 对象,调用enqueue方法传入回调 基本函数调用链 Retrofit.Build 建造者模式 Retrofit.create() 创建相应Api interface eagerlyValidateMethods 校验解析所有method,即定义的每个api method ServiceMethod.build() 解析interface所有method，每个method的参数封装成ServiceMethod ServiceMethod.createCallAdapter() 每个method寻找匹配的CallAdapter，即返回值转换器 Retrofit.callAdapter() 遍历retrofit配置过的adapter，寻找匹配的那个 Retrofit.nextCallAdapter() ServiceMethod.createResponseConverter() 创建response转换器 Retrofit.responseBodyConverter() 寻找匹配的responseConverter Retrofit.nextResponseBodyConverter() ServiceMethod.parseMethodAnnotation() 解析标记方法的每个注解，比如Get,Post等常见注解就是在这里解析 ServiceMethod.parseHttpMethodAndPath() 解析具体的Http注解和path，比如GET ServiceMethod.parsePathParameters() 解析url包含的路径参数，即{path}，params必须包含@Path ServiceMethod.parseHeaders() 解析head，通过@Headers判断 ServiceMethod.parseParameter() 解析每个param,返回ParameterHandler ServiceMethod.parseParameterAnnotation() 解析参数的具体注解,常见的有@path,@query等,requestConverter和stringConverter在这会被调用 ParameterHandler 这个类主要是api方法参数的各种具体处理，添加到RequestBuilder Proxy.newProxyInstance() 动态代理，代理整个Api interface，当我们调用api方法时，会调用这个代理的invoke()方法，这是retrofit的核心 OkHttpCall OKHttp具体请求网络的地方,拿出初始化传入的OkHttpClient，拿出ServiceMethod.toRequest()的Request，然后怼到一起，调用okhttp的api进行网络请求和回调处理，在parseResponse()中会调用responseConverter CallAdapter.adapt() Android默认的CallAdapter在ExecutorCallAdapterFactory里，返回的是Call,另外提供的有RxJava2CallAdapter,返回值是Observable 关键点的代码查看 为什么只用定义一个interface，达到直接调用的效果 利用了Java动态代理机制,和 AOP 一个原理，相关代码在Retrofit.create(); 123456789101112131415return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[]&#123;service&#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //...... //NOTE-Blanke: 加载这个method，如果设置validateEagerly=true,这里是直接获取serviceMethodCache里的缓存 ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); //NOTE-Blanke: 默认http调用OKHttp，这里可以扩展，换成别家的http框架 OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); 平常使用最多的是json，相关转换代码 以Gson解析为例,相关代码在retrofit2.converter.gson. requestConvert 见GsonRequestBodyConverter 具体的转换代码在ParameterHandler.Body，具体调用链是ServiceMethod.parseParameterAnnotation()-&gt;new Body,ServiceMethod.toRequest()-&gt;Body.apply(); responseConvert 见GsonResponseBodyConverter 具体转换代码在ServiceMethod.toResponse().具体调用链是OkHttpCall.parseResponse()-&gt;ServiceMethod.toResponse(); 自定义CallAdapter相关默认的是ExecutorCallAdapterFactory匿名类，默认的返回类型是Call.调用链是Retrofit.create():serviceMethod.callAdapter.adapt(okHttpCall)RxJava是RxJava2CallAdapter，返回类型是Observable自定义demo见ErrorHandlingAdapter 发现的设计模式 建造者模式 出现的Builder类 工厂模式 以Factory结尾的类 代理模式 ExecutorCallbackCall，Retrofit.create()用到了动态代理 策略模式 Converter,CallAdapter等的实现 适配器模式 ErrorHandlingAdapter.MyCallAdapter 迭代器模式 ParameterHandler 外观模式 Retrofit","tags":[{"name":"Android","slug":"Android","permalink":"https://blankeer.github.io/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"https://blankeer.github.io/tags/Retrofit/"}]},{"title":"RxJava 1.x 源码分析","date":"2017-05-21T12:39:36.000Z","path":"2017/05/21/RxJava-1-x-源码分析/","text":"Demo 分析最简单的 demo123456789101112131415161718192021222324Observable.OnSubscribe sourceOnSubscribe = new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Hello\"); subscriber.onNext(\"Hi\"); subscriber.onCompleted(); &#125;&#125;;Observable sourceObservable = Observable.create(sourceOnSubscribe);Subscriber&lt;String&gt; targetSubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;;sourceObservable.subscribe(targetSubscriber); 没有进行简写,每个中间变量都赋予了名字,方便后面说明. demo的输出结果就是 Hello Hi Completed! 基本 demo 的函数调用链分析上述最简单的 demo, 分析中不看 部分与性能、兼容性、扩展性有关的代码和函数调用,仅关注核心代码和调用,在相关源码里,关键部分有相关注释说明. 先上图. demo 实例化 Observable.OnSubscribe , 记为 sourceOnSubscribe. 调用 Observable.create 静态方法 create()内部会实例化 Observable 对象,需要传入sourceOnSubscribe,将其返回值记为 sourceObservable. 实例化 Subscriber , 记为 targetSubscriber. 调用 sourceObservable.subscribe(targetSubscriber) 方法,这是将观察者和观察源建立联系的地方,订阅. sourceObservable 会首先调用 targetSubscriber.onStart() 方法. sourceObservable 调用 sourceOnSubscribe 的 call(targetSubscriber)方法, 就是上面我们自定义的地方,执行到我们写的代码附近了. 执行相关逻辑,上面 demo 中什么都没做,这里需要我们自己实现具体逻辑. 调用 targetSubscriber.onNext(T) 方法,这里也是上面 demo 里自己实现的地方. targetSubscriber.onCompleted() or targetSubscriber.onError(e),整个流程跑完了. 整个调用流程其实并不复杂,跟踪下来还是很容易的,RxJava 在内部也没做太多的事. 深入使用的源码分析RxJava 最强大的就是操作符 和 线程操作,接下来看看这部分. 操作符 map 123456789101112131415Func1 mapFun=new Func1&lt;Integer, String&gt;() &#123; @Override public String call(Integer number) &#123; // 参数类型 int return \"number \" + number; // 返回类型 String &#125; &#125;;Action1 action1=new Action1&lt;String&gt;() &#123; @Override public void call(String str) &#123; // 参数类型 String Log.i(str); &#125; &#125;;Observable.just(1,2,3,4,5).map(mapFun).subscribe(action1); 调用 map(mapFun) map 方法内部实例化 OnSubscribeMap ,传入 this (Observable) 和 mapFun. 调用 Observable.create 方法,生成新的 MapObservable 我们调用 subscribe 时,实际上调用的是 MapObservable.subscribe(). 回调 onStart() 调用 onSubscribeMap 的 call() 生成一个新的 mapSubscriber ,之后会订阅原来的 Observable. 关联两个 subscriber 的 unsubscribe() 用新的 mapSubscriber 订阅原来的 Observable. 原来的 Observable 回调 mapSubscriber的 onStart() 调用原来的 OnSubscribe.call() OnSubscribe 内部的执行逻辑 调用 mapSubscriber 的 onNext(T) mapSubscriber 会调用 mapFun.call(T) 返回 R mapSubscriber 调用真正的 targetSubscriber.onNext(R),R 是转换后的数据 看流程有点复杂,其实也很简单,就是 map 在观察源和观察者之前做了一层转换,当发生订阅时,观察者订阅的不是真正的观察源,而是 map 内部的’转换观察源’,’转换观察源’内部会再去订阅真正的观察源,然后将观察源返回的数据通过转换函数mapFun转换,再返回给我们定义的观察者. lift 变换 123456789101112131415161718192021222324252627282930313233new Func1&lt;Integer, String&gt;() &#123; @Override public String call(Integer number) &#123; // 参数类型 int return \"number \" + number; // 返回类型 String &#125; &#125;; Observable&lt;Integer&gt; observable = Observable.just(1, 2, 3, 4, 5); observable.lift(new Observable.Operator&lt;String, Integer&gt;() &#123; @Override//这个参数 subscriber,就是最终的,也就是我们使用时传入的 public Subscriber&lt;? super Integer&gt; call(final Subscriber&lt;? super String&gt; subscriber) &#123; return new Subscriber&lt;Integer&gt;() &#123; @Override public void onNext(Integer integer) &#123; subscriber.onNext(\"number \" + integer); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; &#125;; &#125; &#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(s); &#125; &#125;); 这个例子功能和上面 map 的例子相同,都是将数字变为字符串. 整体流程和 map 类似,都是生成一个中间 Subscriber ,去订阅原来的 Observable,然后在 onNext 等方法里将数据处理转换之后,回调真正的 Subscriber. 线程控制- subscribeOn() `OperatorSubscribeOn` 新建了一个 OnSubscribe,执行 call() 即产生事件.即 OperatorSubscribeOn,内部调用了线程相关. - observeOn() 使用了 lift 操作符, operator 是 `OperatorObserveOn`.内部也是线程相关代码.","tags":[{"name":"Android","slug":"Android","permalink":"https://blankeer.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"https://blankeer.github.io/tags/RxJava/"}]}]